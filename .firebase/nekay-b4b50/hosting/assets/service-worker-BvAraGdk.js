importScripts("https://cdn.jsdelivr.net/npm/dexie@latest/dist/dexie.min.js");const m="v1",i=`static-cache-${m}`,r=`dynamic-cache-${m}`,l=`api-cache-${m}`,y="/offline.html",f=["/","/index.html","/manifest.json","/offline.html","/notification.mp3","/notification2.wav","/vite.svg","/chart-line-solid.svg","/journal.svg","/taskIcon.svg","/assets/","/src/","/node_modules/","/@vite/client","/assets/moonbg.gif","/assets/melodysticker.gif","/assets/melodysticker.png","/assets/melody3.gif","/assets/bgsky.jpg","/assets/sunsetbg.jpg","/assets/melodystar.png","/assets/melodygoodstickr.jpg","/assets/background.jpg","/assets/bgsky.png","/assets/melodyno.gif","/assets/melody.gif","/assets/cloud.png","/assets/melody2.gif","/assets/melodykiss.png","/assets/sleepingmelody.png","/img/icons/apple-touch-icon.png","/img/icons/safari-pinned-tab.svg","/img/icons/android-chrome-192x192.png","/img/icons/android-chrome-512x512.png","/img/icons/android-chrome-maskable-192x192.png","/img/icons/android-chrome-maskable-512x512.png",y],E=50,A=100;class C extends Dexie{constructor(){super("NekayOfflineDB_v2"),this.version(1).stores({tasks:"id, syncStatus, folderId, lastModified",journal:"id, syncStatus, folderId, date, lastModified",folders:"id, syncStatus, type, lastModified",notes:"id, syncStatus, lastModified",pomodoro:"id, syncStatus, type, startTime, lastModified",syncQueue:"++id, action, store, timestamp"})}}const n=new C;self.addEventListener("install",e=>{e.waitUntil(Promise.all([caches.open(i).then(t=>(console.log("Caching static assets"),t.addAll(f))),caches.open(r),caches.open(l),n.open().catch(t=>console.error("Failed to open database:",t))])),self.skipWaiting()});self.addEventListener("activate",e=>{e.waitUntil(Promise.all([T(),self.clients.claim(),n.open().catch(t=>console.error("Failed to open database:",t))]))});async function T(){const e="cache-cleanup-lock";if(await caches.match(e)){console.log("Cache cleanup already in progress");return}try{await(await caches.open(i)).put(e,new Response("locked"));const s=(await caches.keys()).filter(c=>c.startsWith("static-cache-")&&c!==i||c.startsWith("dynamic-cache-")&&c!==r||c.startsWith("api-cache-")&&c!==l);await Promise.all([...s.map(c=>caches.delete(c)),u(r,E),u(l,A)])}finally{await(await caches.open(i)).delete(e)}}async function u(e,t){const a=await caches.open(e),s=await a.keys();if(s.length>t){console.log(`Trimming cache ${e}, current size: ${s.length}`);for(let c=0;c<s.length-t;c++)await a.delete(s[c])}}self.addEventListener("fetch",e=>{const t=new URL(e.request.url);if(!(e.request.method!=="GET"||t.pathname.includes("browser-sync"))){if(t.pathname.startsWith("/api/")){e.respondWith(_(e));return}if(f.some(a=>t.pathname.includes(a))){e.respondWith(S(e));return}e.respondWith(R(e))}});const p=3,k=1e3;async function _(e){let t=0;for(;t<p;)try{const a=await fetch(e.request),s=a.headers.get("Cache-Control"),c=!s||!s.includes("no-store");if(!a.ok)throw new Error(`HTTP error! status: ${a.status}`);if(c&&a.ok){const o=await caches.open(l);try{await o.put(e.request,a.clone())}catch(d){console.error("Failed to cache API response:",d)}}return a}catch(a){if(t++,console.error(`API request failed (attempt ${t}/${p}):`,a),t===p){if(e.request.method!=="GET"){const s=e.request.clone();await M(s)}if(e.request.method==="GET"){const s=await caches.match(e.request);if(s)return s}throw a}await new Promise(s=>setTimeout(s,k))}}function S(e){e.respondWith(caches.match(e.request).then(t=>t||fetch(e.request)))}async function R(e){const t=await caches.open(r);try{const a=await fetch(e.request);if(a.ok)return await t.put(e.request,a.clone()),a}catch{const s=await t.match(e.request);if(s)return s}return t.match(y)}async function M(e){try{const t=e.clone();let a;try{a=await t.text()}catch{a=null}const s={url:e.url,method:e.method,headers:Array.from(e.headers.entries()),body:a,mode:e.mode,credentials:e.credentials,cache:e.cache,timestamp:Date.now()};await n.syncQueue.add({action:"api",store:"requests",data:s,timestamp:Date.now(),attempts:0}),(await self.clients.matchAll()).forEach(o=>{o.postMessage({type:"SYNC_QUEUED",payload:{url:e.url,method:e.method,timestamp:Date.now()}})})}catch(t){throw console.error("Failed to queue request:",t),t}}self.addEventListener("sync",e=>{e.tag==="sync-data"&&e.waitUntil(I())});async function I(){const t=await self.clients.matchAll();try{const a=await n.syncQueue.toArray();console.log(`Processing ${a.length} pending items`);for(const s of a)try{s.action==="api"&&s.attempts<5?(await q(s.data),await n.syncQueue.delete(s.id),t.forEach(c=>{c.postMessage({type:"SYNC_COMPLETED",payload:{id:s.id,timestamp:Date.now()}})})):s.attempts>=5&&(console.log(`Item ${s.id} exceeded max retry attempts, marking as failed`),await n.syncQueue.delete(s.id),t.forEach(c=>{c.postMessage({type:"SYNC_FAILED",payload:{id:s.id,error:"Exceeded maximum retry attempts"}})}))}catch(c){console.error(`Failed to process sync item ${s.id}:`,c),await n.syncQueue.update(s.id,{attempts:(s.attempts||0)+1}),t.forEach(o=>{o.postMessage({type:"SYNC_ERROR",payload:{id:s.id,error:c.message}})})}}catch(a){throw console.error("Sync failed:",a),t.forEach(s=>{s.postMessage({type:"SYNC_FAILED",payload:{error:a.message}})}),a}}async function q(e){try{const{url:t,method:a,headers:s,body:c,mode:o,credentials:d,cache:g}=e,w=new Request(t,{method:a,headers:new Headers(s),body:c||null,mode:o,credentials:d,cache:g}),h=await fetch(w);if(!h.ok)throw new Error(`HTTP error! status: ${h.status}`);return h}catch(t){throw console.error("Failed to process sync request:",t),t}}
