importScripts("https://cdn.jsdelivr.net/npm/dexie@latest/dist/dexie.min.js");const m="v1",n=`static-cache-${m}`,r=`dynamic-cache-${m}`,d=`api-cache-${m}`,f="/offline.html",y=["/","/index.html","/manifest.json","/offline.html","/notification.mp3","/notification2.wav","/vite.svg","/chart-line-solid.svg","/journal.svg","/taskIcon.svg","/assets/","/src/","/node_modules/","/@vite/client","/assets/moonbg.gif","/assets/melodysticker.gif","/assets/melodysticker.png","/assets/melody3.gif","/assets/bgsky.jpg","/assets/sunsetbg.jpg","/assets/melodystar.png","/assets/melodygoodstickr.jpg","/assets/background.jpg","/assets/bgsky.png","/assets/melodyno.gif","/assets/melody.gif","/assets/cloud.png","/assets/melody2.gif","/assets/melodykiss.png","/assets/sleepingmelody.png","/img/icons/apple-touch-icon.png","/img/icons/safari-pinned-tab.svg","/img/icons/android-chrome-192x192.png","/img/icons/android-chrome-512x512.png","/img/icons/android-chrome-maskable-192x192.png","/img/icons/android-chrome-maskable-512x512.png",f],A=50,C=100;class T extends Dexie{constructor(){super("NekayOfflineDB_v2"),this.version(1).stores({tasks:"id, syncStatus, folderId, lastModified",journal:"id, syncStatus, folderId, date, lastModified",folders:"id, syncStatus, type, lastModified",notes:"id, syncStatus, lastModified",pomodoro:"id, syncStatus, type, startTime, lastModified",syncQueue:"++id, action, store, timestamp"})}}const i=new T;self.addEventListener("install",e=>{e.waitUntil(Promise.all([caches.open(n).then(t=>(console.log("Caching static assets"),t.addAll(y))),caches.open(r),caches.open(d),i.open().catch(t=>console.error("Failed to open database:",t))])),self.skipWaiting()});self.addEventListener("activate",e=>{e.waitUntil(Promise.all([k(),self.clients.claim(),i.open().catch(t=>console.error("Failed to open database:",t))]))});async function k(){const e="cache-cleanup-lock";if(await caches.match(e)){console.log("Cache cleanup already in progress");return}try{await(await caches.open(n)).put(e,new Response("locked"));const s=(await caches.keys()).filter(o=>o.startsWith("static-cache-")&&o!==n||o.startsWith("dynamic-cache-")&&o!==r||o.startsWith("api-cache-")&&o!==d);await Promise.all([...s.map(o=>caches.delete(o)),u(r,A),u(d,C)])}finally{await(await caches.open(n)).delete(e)}}async function u(e,t){const a=await caches.open(e),s=await a.keys();if(s.length>t){console.log(`Trimming cache ${e}, current size: ${s.length}`);for(let o=0;o<s.length-t;o++)await a.delete(s[o])}}self.addEventListener("fetch",e=>{const t=new URL(e.request.url);if(!(e.request.method!=="GET"||t.pathname.includes("browser-sync"))){if(t.pathname.startsWith("/api/")){e.respondWith(S(e));return}if(y.some(a=>t.pathname.includes(a))){e.respondWith(R(e));return}e.respondWith(M(e))}});const p=3,_=1e3;async function S(e){let t=0;for(;t<p;)try{const a=await fetch(e.request),s=a.headers.get("Cache-Control"),o=!s||!s.includes("no-store");if(!a.ok)throw new Error(`HTTP error! status: ${a.status}`);if(o&&a.ok){const c=await caches.open(d);try{await c.put(e.request,a.clone())}catch(l){console.error("Failed to cache API response:",l)}}return a}catch(a){if(t++,console.error(`API request failed (attempt ${t}/${p}):`,a),t===p){if(e.request.method!=="GET"){const s=e.request.clone();await I(s)}if(e.request.method==="GET"){const s=await caches.match(e.request);if(s)return s}throw a}await new Promise(s=>setTimeout(s,_))}}function R(e){e.respondWith(caches.match(e.request).then(t=>t||fetch(e.request)))}async function M(e){const t=await caches.open(r);try{const a=await fetch(e.request);if(a.ok)return await t.put(e.request,a.clone()),a}catch{const s=await t.match(e.request);if(s)return s}return t.match(f)}async function I(e){try{const t=e.clone();let a;try{a=await t.text()}catch{a=null}const s={url:e.url,method:e.method,headers:Array.from(e.headers.entries()),body:a,mode:e.mode,credentials:e.credentials,cache:e.cache,timestamp:Date.now()};await i.syncQueue.add({action:"api",store:"requests",data:s,timestamp:Date.now(),attempts:0}),(await self.clients.matchAll()).forEach(c=>{c.postMessage({type:"SYNC_QUEUED",payload:{url:e.url,method:e.method,timestamp:Date.now()}})})}catch(t){throw console.error("Failed to queue request:",t),t}}self.addEventListener("sync",e=>{e.tag==="sync-data"&&e.waitUntil(g())});self.addEventListener("periodicsync",e=>{e.tag==="regular-update"&&e.waitUntil(g())});self.addEventListener("push",e=>{const t={body:e.data.text(),icon:"/img/icons/android-chrome-192x192.png",badge:"/img/icons/android-chrome-192x192.png",vibrate:[100,50,100],data:{dateOfArrival:Date.now(),primaryKey:1}};e.waitUntil(self.registration.showNotification("Nekay Update",t))});self.addEventListener("notificationclick",e=>{e.notification.close(),e.waitUntil(clients.openWindow("/"))});async function g(){const t=await self.clients.matchAll();try{const a=await i.syncQueue.toArray();console.log(`Processing ${a.length} pending items`);for(const s of a)try{s.action==="api"&&s.attempts<5?(await q(s.data),await i.syncQueue.delete(s.id),t.forEach(o=>{o.postMessage({type:"SYNC_COMPLETED",payload:{id:s.id,timestamp:Date.now()}})})):s.attempts>=5&&(console.log(`Item ${s.id} exceeded max retry attempts, marking as failed`),await i.syncQueue.delete(s.id),t.forEach(o=>{o.postMessage({type:"SYNC_FAILED",payload:{id:s.id,error:"Exceeded maximum retry attempts"}})}))}catch(o){console.error(`Failed to process sync item ${s.id}:`,o),await i.syncQueue.update(s.id,{attempts:(s.attempts||0)+1}),t.forEach(c=>{c.postMessage({type:"SYNC_ERROR",payload:{id:s.id,error:o.message}})})}}catch(a){throw console.error("Sync failed:",a),t.forEach(s=>{s.postMessage({type:"SYNC_FAILED",payload:{error:a.message}})}),a}}async function q(e){try{const{url:t,method:a,headers:s,body:o,mode:c,credentials:l,cache:w}=e,E=new Request(t,{method:a,headers:new Headers(s),body:o||null,mode:c,credentials:l,cache:w}),h=await fetch(E);if(!h.ok)throw new Error(`HTTP error! status: ${h.status}`);return h}catch(t){throw console.error("Failed to process sync request:",t),t}}
